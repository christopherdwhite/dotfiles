#!/usr/bin/env bash

# # bash prompt
#
# this configuration is heavily inspired, or in parts, forked from Mathias Bynems' exceptional prompt
# https://github.com/mathiasbynens/dotfiles/blob/master/.bash_prompt
#

# # colors & style
#
# define the colors and style as both tput commands and ANSI escape codes for most compatibility.
# unused colors are commented to prevent ShellCheck warnings but are kept for possible expansions in the future.
#
if tput setaf 1 &> /dev/null; then # if tput commands are supported

	# color
	foreground=$(tput setaf 0);
	# black=$(tput setaf 0);
	# gray=$(tput setaf 244);
	lightGray=$(tput setaf 250);
	# white=$(tput setaf 15);

	red=$(tput setaf 1);
	# redBright=$(tput setaf 9);
	magenta=$(tput setaf 5);
	# magentaBright=$(tput setaf 13);
	blue=$(tput setaf 4);
	# blueBright=$(tput setaf 27);
	cyan=$(tput setaf 6);
	# cyanBright=$(tput setaf 14);
	green=$(tput setaf 2);
	# greenBright=$(tput setaf 10);
	yellow=$(tput setaf 3);
	# yellowBright=$(tput setaf 11);
	orange=$(tput setaf 130);
	# orangeBright=$(tput setaf 208);

	# style
	bold=$(tput bold);
	reset=$(tput sgr0);

else # otherwise use ANSI escape codes

	# color
	foreground="\e[39m"
	# black="\e[38;5;0m"
	# gray="\e[38;5;244m"
	lightGray="\e[38;5;250m"
	# white="\e[38;5;15m"

	red="\e[38;5;1m"
	# redBright="\e[38;5;9m"
	magenta="\e[38;5;5m"
	# magentaBright="\e[38;5;13m"
	blue="\e[38;5;4m"
	# blueBright="\e[38;5;27m"
	cyan="\e[38;5;6m"
	# cyanBright="\e[38;5;14m"
	green="\e[38;5;2m"
	# greenBright="\e[38;5;10m"
	yellow="\e[38;5;3m"
	# yellowBright="\e[38;5;11m"
	orange="\e[38;5;130m"
	# orangeBright="\e[38;5;208m"

	# style
	bold="\e[1m";
	reset="\e[0m";

fi;


# # title
#
# The text that will be used for the terminal/tab title
#
case "$TERM" in
xterm*|rxvt*)
    PROMPT_COMMAND='echo -ne "\033]0;${PWD##*/}\007"'
    show_command_in_title_bar()
    {
        case "$BASH_COMMAND" in
            *\033]0*)
                ;;
            *)
                echo -ne "\033]0;${BASH_COMMAND} - ${PWD##*/}\007"
                ;;
        esac
    }
    trap show_command_in_title_bar DEBUG
    ;;
*)
    ;;
esac

# # user
#
# Set different user colors and prompt characters depending on running as root or anything else
#
if [[ "${USER}" = "root" ]]; then
	userStyle="${bold}${red}";
	promptCharacter="${bold}#";
else
	userStyle="${bold}${blue}"
	promptCharacter=">";
fi


# # hostname
#
# if SSH set hostname to yellow, if cportable set it to cyan, otherwise, set it to orange
#
if [[ "${SSH_TTY}" ]]; then
	hostStyle="${bold}${yellow}";
elif [[ "${HOSTNAME%%.*}" = "cportable" ]]; then
	hostStyle="${bold}${cyan}";
else
	hostStyle="${bold}${orange}";
fi;


# # git
#
# if working directory is a git repository, echo branch name and status to prompt
#
prompt_git() {
	exitCode=$?; # preserve last exit code to return
	local s='';
	local branchName='';

	# Check if the current directory is in a Git repository.
	if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

		# check if the current directory is in .git before running git checks
		if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

			# Ensure the index is up to date.
			git update-index --really-refresh -q &>/dev/null;

			# Check for uncommitted changes in the index.
			if ! $(git diff --quiet --ignore-submodules --cached); then
				s+='+';
			fi;

			# Check for unstaged changes.
			if ! $(git diff-files --quiet --ignore-submodules --); then
				s+='!';
			fi;

			# Check for untracked files.
			if [ -n "$(git ls-files --others --exclude-standard)" ]; then
				s+='?';
			fi;

			# Check for stashed files.
			if $(git rev-parse --verify refs/stash &>/dev/null); then
				s+='$';
			fi;

		fi;

		# Get the short symbolic ref.
		# If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
		# Otherwise, just give up.
		branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
			git rev-parse --short HEAD 2> /dev/null || \
			echo '(unknown)')";

		[ -n "${s}" ] && s=" [${s}]";

		echo -e "${1}${branchName}${2}${s}";
		return "${exitCode}"; # return exit code from previous command
	else
		return "${exitCode}"; # return exit code from previous command
	fi;
}


# # previous command exit
#
# If the last command failed turn the prompt character red, otherwise set it to light gray
#
prompt_exit() {
	if [ "${?}" = "0" ]; then
		echo -e "${lightGray}";
	else
		echo -e "${bold}${red}";
	fi
}


# # prompt constructor
#
# the title matches: `shell name: pwd`
# the final prompt matches:
# ```
#
# username at host in pwd (on branch [git status])
#  > _
# ```
#
# The section within parenthesis will only appear within Git repors.
# The prompt character changes from `>` to `⌘` when running as root
#
PS1=""                                                                           # define empty var
# PS1+="\[\e]0;\[${title}\]\007\]";                                                # title
PS1+="\n";                                                                       # new line
PS1+="\[${userStyle}\]\u\[${reset}\]";                                           # username
PS1+=" at ";                                                                     # `at`
PS1+="\[${hostStyle}\]\h\[${reset}\]";                                           # hostname
PS1+=" in ";                                                                     # `in`
PS1+="\[${bold}${green}\]\w\[${reset}\]";                                        # pwd
PS1+="\$(prompt_git \"\[${foreground}\] on \[${magenta}\]\" \"\[${yellow}\]\")"; # Git repository details
PS1+="\n";                                                                       # new line
PS1+="\[\$(prompt_exit)\] ${promptCharacter} \[${reset}\]";                      # prompt character

PS2="\[${lightGray}\] + \[${reset}\]";
